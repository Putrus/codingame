#include <iostream>
#include <vector>
#include <unordered_set>
#include <deque>
using namespace std;enum class M:int{S=0,U,D,L,R};bool operator<(M l,M r){return static_cast<int>(l)<static_cast<int>(r);}ostream&operator<<(ostream&o,M&m){switch(m){case M::U:{o<<"UP";break;}case M::D:{o<<"DOWN";break;}case M::L:{o<<"LEFT";break;}case M::R:{o<<"RIGHT";break;}default:{o<<"W";break;}}return o;}struct P{int x=0,y=0;};istream&operator>>(istream&i,P&p){i>>p.x>>p.y;return i;}bool operator==(const P&l,const P&r){return l.x==r.x&&l.y==r.y;}P operator+(const P&l,const P&r){return{l.x+r.x,l.y+r.y};}namespace std{template<>struct hash<P>{size_t operator()(const P&p)const noexcept{size_t h=17;h=h*31+hash<int>{}(p.x);h=h*31+hash<int>{}(p.y);return h;}};}enum class A{C,G,T};int main(){int r,c,a,v,f,i;cin>>r>>c>>a;A p=A::C;char w='?';for(;;){cin>>v>>f;vector<string>z;for(i=0;i<r;++i){string e;cin>>e;z.push_back(e);}if(z[v][f]=='C'){w='T';}M m=M::S;while(m==M::S){unordered_set<P>h;deque<pair<P, M>>q;q.push_back({{f,v},M::S});h.insert({f,v});while(!q.empty()){auto u = q.front();q.pop_front();if(z[u.first.y][u.first.x]==w){m=u.second;break;}for(M n:{M::U,M::D,M::L,M::R}){P l=u.first;switch(n){case M::U:{--l.y;break;}case M::D:{++l.y;break;}case M::R:{++l.x;break;}case M::L:{--l.x;break;}default:{cerr<<"W"<<endl;break;}}if(l.y>=0&&l.y<z.size()&&l.x>=0&&l.x<z[l.y].size()&&z[l.y][l.x]!='#'&&h.find(l)==h.end()){if(u.second==M::S){q.push_back({l,n});h.insert(l);}else{q.push_back({l,u.second});h.insert(l);}}}}if(w=='?'&&m==M::S){w='C';}}cout<<m<<endl;}}